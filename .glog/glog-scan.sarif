{
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "Glog.AI",
          "organization": "Glog.AI",
          "fullName": "Glog, Making software more secure",
          "version": "1.0.0",
          "semanticVersion": "1.0.0",
          "informationUri": "https://www.glog.ai",
          "rules": [
            {
              "id": "028f8d1f-660f-3720-aad1-2f621a349a10",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. One such function is `printf`.\n\nThe `printf` function is a common function in C and C++ for outputting text. However, it can be dangerous if used improperly, especially when handling user-supplied input. This is because `printf` can interpret certain special characters (like `%s`, `%d`, etc.) and if an attacker can control the format string, they can potentially exploit this to execute arbitrary code, read from or write to arbitrary memory locations, or cause the program to crash.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` with user-supplied input. Instead, use safer alternatives that do not interpret format strings, such as `puts` or `fputs`. If you need to format strings, use functions like `snprintf` that limit the amount of output, and always use a static format string.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nchar* user_input = get_user_input();\nprintf(user_input);\n```\n\nUse:\n\n```cpp\nchar* user_input = get_user_input();\nputs(user_input);\n```\n\nOr, if you need to format strings:\n\n```cpp\nchar* user_input = get_user_input();\nchar buffer[256];\nsnprintf(buffer, sizeof(buffer), \"%s\", user_input);\nputs(buffer);\n```\n\n## Library Dependencies\n\nThe code examples above require the following library:\n\n```cpp\n#include <stdio.h>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "49243c74-9c7d-33d5-b218-45c70e89c8e3",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. One such function is `printf`.\n\nThe `printf` function is a common function in C and C++ for outputting text. However, it can be dangerous if used improperly, especially when handling user-supplied input. This is because `printf` can interpret certain special characters (like `%s`, `%d`, etc.) and if an attacker can control the format string, they can potentially exploit this to execute arbitrary code, read from or write to arbitrary memory locations, or cause the program to crash.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` with user-supplied input. Instead, use safer alternatives that do not interpret format strings, such as `puts` or `fputs`. If you need to format strings, use functions like `snprintf` that limit the amount of output, and always use a static format string.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nchar* user_input = get_user_input();\nprintf(user_input);\n```\n\nUse:\n\n```cpp\nchar* user_input = get_user_input();\nputs(user_input);\n```\n\nOr, if you need to format strings:\n\n```cpp\nchar* user_input = get_user_input();\nchar buffer[256];\nsnprintf(buffer, sizeof(buffer), \"%s\", user_input);\nputs(buffer);\n```\n\n## Library Dependencies\n\nThe code examples above require the following library:\n\n```cpp\n#include <stdio.h>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "ae47b75d-e0b8-3c64-a026-299e93f80329",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. One such function is `printf`.\n\nThe `printf` function is a common function in C and C++ for outputting text. However, it can be dangerous if used improperly, especially when handling user-supplied input. This is because `printf` can interpret certain special characters (like `%s`, `%d`, etc.) and if an attacker can control the format string, they can potentially exploit this to execute arbitrary code, read from or write to arbitrary memory locations, or cause the program to crash.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` with user-supplied input. Instead, use safer alternatives that do not interpret format strings, such as `puts` or `fputs`. If you need to format strings, use functions like `snprintf` that limit the amount of output, and always use a static format string.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nchar* user_input = get_user_input();\nprintf(user_input);\n```\n\nUse:\n\n```cpp\nchar* user_input = get_user_input();\nputs(user_input);\n```\n\nOr, if you need to format strings:\n\n```cpp\nchar* user_input = get_user_input();\nchar buffer[256];\nsnprintf(buffer, sizeof(buffer), \"%s\", user_input);\nputs(buffer);\n```\n\n## Library Dependencies\n\nThe code examples above require the following library:\n\n```cpp\n#include <stdio.h>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "26aaa792-ef8b-3990-a8d5-01d40f91f5ca",
              "help": {
                "text": "",
                "markdown": "## Description\n\nUnsecured URL Vulnerability refers to the security risk that arises when a program allows an attacker to control the URL to which it connects. This can lead to a variety of attacks, such as forcing the program to connect to a malicious server, or to download and execute malicious content. In C++ programming, this vulnerability can occur when a program uses a URL that is input by the user or otherwise not hard-coded into the program.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to validate all URLs before using them to establish a connection. This can be done by checking the URL against a whitelist of known, trusted URLs. Additionally, it is advisable to use secure connections (HTTPS) whenever possible, to prevent man-in-the-middle attacks.\n\n## Source Code Fix Recommendation\n\nThe following is a simple example of how to validate a URL in C++:\n\n```cpp\n#include <iostream>\n#include <string>\n#include <regex>\n\nbool isValidURL(const std::string& url)\n{\n    // This is a simple regex for URL validation\n    std::regex url_regex(\n        R\"(^https://([a-z]+\\.)?[a-z]+\\.[a-z]+/?$)\",\n        std::regex::icase\n    );\n\n    return std::regex_match(url, url_regex);\n}\n\nint main()\n{\n    std::string url = \"http://thrust.github.io\";\n\n    if (!isValidURL(url))\n    {\n        std::cerr << \"Invalid URL: \" << url << std::endl;\n        return 1;\n    }\n\n    // Proceed with connecting to the URL...\n}\n```\n\nThis code checks if the URL starts with \"https://\" and is followed by a valid domain name. If the URL is not valid, the program prints an error message and exits with a non-zero status code.\n\n## Library Dependencies\n\nThe above code requires the following libraries:\n\n- iostream\n- string\n- regex\n\n## References\n\n- [OWASP Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html)\n- [CWE-601: URL Redirection to Untrusted Site ('Open Redirect')](https://cwe.mitre.org/data/definitions/601.html)"
              },
              "properties": {
                "tags": [
                  "DS137138"
                ]
              }
            },
            {
              "id": "1fb8ff2b-6bab-3f63-b10b-cc7d8cdaace7",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. One such function is `printf`.\n\nThe `printf` function is a common function in C and C++ for outputting text. However, it can be dangerous if used improperly, especially when handling user-supplied input. This is because `printf` can interpret certain special characters (like `%s`, `%d`, etc.) and if an attacker can control the format string, they can potentially exploit this to execute arbitrary code, read from or write to arbitrary memory locations, or cause the program to crash.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` with user-supplied input. Instead, use safer alternatives that do not interpret format strings, such as `puts` or `fputs`. If you need to format strings, use functions like `snprintf` that limit the amount of output, and always use a static format string.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nchar* user_input = get_user_input();\nprintf(user_input);\n```\n\nUse:\n\n```cpp\nchar* user_input = get_user_input();\nputs(user_input);\n```\n\nOr, if you need to format strings:\n\n```cpp\nchar* user_input = get_user_input();\nchar buffer[256];\nsnprintf(buffer, sizeof(buffer), \"%s\", user_input);\nputs(buffer);\n```\n\n## Library Dependencies\n\nThe code examples above require the following library:\n\n```cpp\n#include <stdio.h>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "5d37606b-996f-3178-9684-12b060b1d66a",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. One such function is `printf`.\n\nThe `printf` function is a common function in C and C++ for outputting text. However, it can be dangerous if used improperly, especially when handling user-supplied input. This is because `printf` can interpret certain special characters (like `%s`, `%d`, etc.) and if an attacker can control the format string, they can potentially exploit this to execute arbitrary code, read from or write to arbitrary memory locations, or cause the program to crash.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` with user-supplied input. Instead, use safer alternatives that do not interpret format strings, such as `puts` or `fputs`. If you need to format strings, use functions like `snprintf` that limit the amount of output, and always use a static format string.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nchar* user_input = get_user_input();\nprintf(user_input);\n```\n\nUse:\n\n```cpp\nchar* user_input = get_user_input();\nputs(user_input);\n```\n\nOr, if you need to format strings:\n\n```cpp\nchar* user_input = get_user_input();\nchar buffer[256];\nsnprintf(buffer, sizeof(buffer), \"%s\", user_input);\nputs(buffer);\n```\n\n## Library Dependencies\n\nThe code examples above require the following library:\n\n```cpp\n#include <stdio.h>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "ebfb17ce-f98e-3ece-865a-080698d3312e",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. One such function is `printf`.\n\nThe `printf` function is a common function in C and C++ for outputting text. However, it can be dangerous if used improperly, especially when handling user-supplied input. This is because `printf` can interpret certain special characters (like `%s`, `%d`, etc.) and if an attacker can control the format string, they can potentially exploit this to execute arbitrary code, read from or write to arbitrary memory locations, or cause the program to crash.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` with user-supplied input. Instead, use safer alternatives that do not interpret format strings, such as `puts` or `fputs`. If you need to format strings, use functions like `snprintf` that limit the amount of output, and always use a static format string.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nchar* user_input = get_user_input();\nprintf(user_input);\n```\n\nUse:\n\n```cpp\nchar* user_input = get_user_input();\nputs(user_input);\n```\n\nOr, if you need to format strings:\n\n```cpp\nchar* user_input = get_user_input();\nchar buffer[256];\nsnprintf(buffer, sizeof(buffer), \"%s\", user_input);\nputs(buffer);\n```\n\n## Library Dependencies\n\nThe code examples above require the following library:\n\n```cpp\n#include <stdio.h>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "ff19dbe8-92d8-3ca4-830d-38363e12d0f2",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. One such function is `printf`.\n\nThe `printf` function is a common function in C and C++ for outputting text. However, it can be dangerous if used improperly, especially when handling user-supplied input. This is because `printf` can interpret certain special characters (like `%s`, `%d`, etc.) and if an attacker can control the format string, they can potentially exploit this to execute arbitrary code, read from or write to arbitrary memory locations, or cause the program to crash.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` with user-supplied input. Instead, use safer alternatives that do not interpret format strings, such as `puts` or `fputs`. If you need to format strings, use functions like `snprintf` that limit the amount of output, and always use a static format string.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nchar* user_input = get_user_input();\nprintf(user_input);\n```\n\nUse:\n\n```cpp\nchar* user_input = get_user_input();\nputs(user_input);\n```\n\nOr, if you need to format strings:\n\n```cpp\nchar* user_input = get_user_input();\nchar buffer[256];\nsnprintf(buffer, sizeof(buffer), \"%s\", user_input);\nputs(buffer);\n```\n\n## Library Dependencies\n\nThe code examples above require the following library:\n\n```cpp\n#include <stdio.h>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "eb4f5517-af60-3eef-961e-d39fcb78859a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `malloc` function in C++ is used to dynamically allocate memory at runtime. However, it can be a source of vulnerabilities if not used properly. The most common issues are:\n\n- Not checking if `malloc` returns `NULL`, which indicates that the memory allocation failed. This can lead to null pointer dereferencing, which is a serious vulnerability that can crash the program or lead to arbitrary code execution.\n- Not initializing the allocated memory, which can lead to information leakage.\n- Allocating too much memory, which can lead to integer overflow or underflow, and subsequently to buffer overflow vulnerabilities.\n\n## Mitigation Advice\n\n- Always check if `malloc` returns `NULL`. If it does, handle the error gracefully.\n- Initialize the allocated memory to a known value, preferably zero, using `memset` or `calloc`.\n- Be careful with the amount of memory you allocate. Make sure it's not too large to prevent integer overflow or underflow.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to use `malloc` safely:\n\n```cpp\n#include <cstdlib>\n#include <cstring>\n\nvoid* safe_malloc(std::size_t n) {\n    void* ptr = std::malloc(n);\n    if (ptr == NULL) {\n        // handle error\n        std::exit(EXIT_FAILURE);\n    }\n    std::memset(ptr, 0, n);\n    return ptr;\n}\n```\n\nIn this code, we first check if `malloc` returns `NULL`. If it does, we handle the error by exiting the program. Then, we initialize the allocated memory to zero using `memset`.\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `<cstdlib>` for `std::malloc` and `std::exit`\n- `<cstring>` for `std::memset`\n\n## References\n\n- [CWE-690: Unchecked Return Value to NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/690.html)\n- [CWE-908: Use of Uninitialized Resource](https://cwe.mitre.org/data/definitions/908.html)\n- [CWE-680: Integer Overflow to Buffer Overflow](https://cwe.mitre.org/data/definitions/680.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "02e60970-02c5-306f-a865-3107d5a9d415",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `malloc` function in C++ is used to dynamically allocate memory at runtime. However, it can be a source of vulnerabilities if not used properly. The most common issues are:\n\n- Not checking if `malloc` returns `NULL`, which indicates that the memory allocation failed. This can lead to null pointer dereferencing, which is a serious vulnerability that can crash the program or lead to arbitrary code execution.\n- Not initializing the allocated memory, which can lead to information leakage.\n- Allocating too much memory, which can lead to integer overflow or underflow, and subsequently to buffer overflow vulnerabilities.\n\n## Mitigation Advice\n\n- Always check if `malloc` returns `NULL`. If it does, handle the error gracefully.\n- Initialize the allocated memory to a known value, preferably zero, using `memset` or `calloc`.\n- Be careful with the amount of memory you allocate. Make sure it's not too large to prevent integer overflow or underflow.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to use `malloc` safely:\n\n```cpp\n#include <cstdlib>\n#include <cstring>\n\nvoid* safe_malloc(std::size_t n) {\n    void* ptr = std::malloc(n);\n    if (ptr == NULL) {\n        // handle error\n        std::exit(EXIT_FAILURE);\n    }\n    std::memset(ptr, 0, n);\n    return ptr;\n}\n```\n\nIn this code, we first check if `malloc` returns `NULL`. If it does, we handle the error by exiting the program. Then, we initialize the allocated memory to zero using `memset`.\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `<cstdlib>` for `std::malloc` and `std::exit`\n- `<cstring>` for `std::memset`\n\n## References\n\n- [CWE-690: Unchecked Return Value to NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/690.html)\n- [CWE-908: Use of Uninitialized Resource](https://cwe.mitre.org/data/definitions/908.html)\n- [CWE-680: Integer Overflow to Buffer Overflow](https://cwe.mitre.org/data/definitions/680.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "170923f4-5c91-3798-a1c0-53b222a7db73",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `malloc` function in C++ is used to dynamically allocate memory at runtime. The vulnerability arises when the size of the memory to be allocated is not properly validated or calculated, leading to buffer overflow, memory corruption, or other related issues. This can potentially allow an attacker to execute arbitrary code or cause a Denial of Service (DoS) attack.\n\n## Mitigation Advice\n\n1. Always validate the size of the memory to be allocated. Avoid allocating large blocks of memory that could potentially cause the program to run out of memory.\n\n2. Use functions that limit the amount of memory that can be written, such as `strncpy` instead of `strcpy`.\n\n3. Consider using modern C++ features like smart pointers (`std::unique_ptr`, `std::shared_ptr`) which automatically manage memory and help prevent memory leaks.\n\n4. Regularly use static code analysis tools to detect potential vulnerabilities in the code.\n\n## Source Code Fix Recommendation\n\nInstead of using `malloc`, consider using `new` in C++ which is type-safe and throws an exception if the allocation fails.\n\n```cpp\nT* ptr = new T;\n```\n\nRemember to deallocate the memory using `delete` when it is no longer needed.\n\n```cpp\ndelete ptr;\n```\n\n## Library Dependencies\n\nThe `malloc` function is part of the C Standard Library (`<cstdlib>` in C++) and does not require any additional libraries.\n\n## References\n\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-131: Incorrect Calculation of Buffer Size](https://cwe.mitre.org/data/definitions/131.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "ae035c1c-2366-308c-be7a-646d246e134c",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. One such function is `printf`.\n\nThe `printf` function is a common function in C and C++ for outputting text. However, it can be dangerous if used improperly, especially when handling user-supplied input. This is because `printf` can interpret certain special characters (like `%s`, `%d`, etc.) and if an attacker can control the format string, they can potentially exploit this to execute arbitrary code, read from or write to arbitrary memory locations, or cause the program to crash.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` with user-supplied input. Instead, use safer alternatives that do not interpret format strings, such as `puts` or `fputs`. If you need to format strings, use functions like `snprintf` that limit the amount of output, and always use a static format string.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nchar* user_input = get_user_input();\nprintf(user_input);\n```\n\nUse:\n\n```cpp\nchar* user_input = get_user_input();\nputs(user_input);\n```\n\nOr, if you need to format strings:\n\n```cpp\nchar* user_input = get_user_input();\nchar buffer[256];\nsnprintf(buffer, sizeof(buffer), \"%s\", user_input);\nputs(buffer);\n```\n\n## Library Dependencies\n\nThe code examples above require the following library:\n\n```cpp\n#include <stdio.h>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "17cd622b-0488-300c-b25c-90cc5bff81ad",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `malloc()` function in C++ is used to dynamically allocate a block of memory. If the number of bytes requested by `malloc()` is not properly validated, it can lead to several vulnerabilities such as buffer overflow, memory corruption, or denial of service. This is because an attacker could potentially control the size of the memory allocation, leading to unexpected behavior.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to:\n\n1. Always validate the size of the memory allocation. Ensure that the size is not zero and is not larger than the maximum allowable size.\n2. Check the return value of `malloc()`. If the allocation fails, `malloc()` returns a null pointer. Failing to check this can lead to null pointer dereferencing which can cause the program to crash.\n3. Initialize the allocated memory. Uninitialized memory can contain sensitive information from previous operations.\n\n## Source Code Fix Recommendation\n\nHere is a simple example of how to properly use `malloc()`:\n\n```cpp\n#include <stdlib.h>\n\n// ...\n\nsize_t num_bytes = /* some value */;\nif (num_bytes <= 0 || num_bytes > MAX_SIZE) {\n    // Handle error\n}\n\nvoid* ptr = malloc(num_bytes);\nif (ptr == NULL) {\n    // Handle error\n}\n\nmemset(ptr, 0, num_bytes);\n```\n\nIn this example, `MAX_SIZE` should be a defined constant that represents the maximum allowable size.\n\n## Library Dependencies\n\nThe `malloc()` function is part of the C standard library, so no additional libraries are needed.\n\n## References\n\n- [CWE-131: Incorrect Calculation of Buffer Size](https://cwe.mitre.org/data/definitions/131.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "c2636310-528f-3f0b-9397-2815490b2cdf",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. One such function is `printf`.\n\nThe `printf` function is a common function in C and C++ for outputting text. However, it can be dangerous if used improperly, especially when handling user-supplied input. This is because `printf` can interpret certain special characters (like `%s`, `%d`, etc.) and if an attacker can control the format string, they can potentially exploit this to execute arbitrary code, read from or write to arbitrary memory locations, or cause the program to crash.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` with user-supplied input. Instead, use safer alternatives that do not interpret format strings, such as `puts` or `fputs`. If you need to format strings, use functions like `snprintf` that limit the amount of output, and always use a static format string.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nchar* user_input = get_user_input();\nprintf(user_input);\n```\n\nUse:\n\n```cpp\nchar* user_input = get_user_input();\nputs(user_input);\n```\n\nOr, if you need to format strings:\n\n```cpp\nchar* user_input = get_user_input();\nchar buffer[256];\nsnprintf(buffer, sizeof(buffer), \"%s\", user_input);\nputs(buffer);\n```\n\n## Library Dependencies\n\nThe code examples above require the following library:\n\n```cpp\n#include <stdio.h>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "23c520eb-78c3-385c-a577-b16d93996cb4",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `malloc()` function in C++ is used to dynamically allocate a block of memory. If the number of bytes requested by `malloc()` is not properly validated, it can lead to several vulnerabilities such as buffer overflow, memory corruption, or denial of service. This is because an attacker could potentially control the size of the memory allocation, leading to unexpected behavior.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to:\n\n1. Always validate the size of the memory allocation. Ensure that the size is not zero and is not larger than the maximum allowable size.\n2. Check the return value of `malloc()`. If the allocation fails, `malloc()` returns a null pointer. Failing to check this can lead to null pointer dereferencing which can cause the program to crash.\n3. Initialize the allocated memory. Uninitialized memory can contain sensitive information from previous operations.\n\n## Source Code Fix Recommendation\n\nHere is a simple example of how to properly use `malloc()`:\n\n```cpp\n#include <stdlib.h>\n\n// ...\n\nsize_t num_bytes = /* some value */;\nif (num_bytes <= 0 || num_bytes > MAX_SIZE) {\n    // Handle error\n}\n\nvoid* ptr = malloc(num_bytes);\nif (ptr == NULL) {\n    // Handle error\n}\n\nmemset(ptr, 0, num_bytes);\n```\n\nIn this example, `MAX_SIZE` should be a defined constant that represents the maximum allowable size.\n\n## Library Dependencies\n\nThe `malloc()` function is part of the C standard library, so no additional libraries are needed.\n\n## References\n\n- [CWE-131: Incorrect Calculation of Buffer Size](https://cwe.mitre.org/data/definitions/131.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "f9beb10d-7c26-371f-aede-940c1f72163e",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Prohibited C Function Found\" is a vulnerability that occurs when a C++ program uses a function that is considered unsafe due to its potential to cause buffer overflow, memory corruption, or other similar issues. The `memmove` function is one of these prohibited functions. It is used to copy a block of memory from one location to another and can lead to vulnerabilities if not used carefully.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to `memmove` such as `memcpy_s` or `memmove_s` which are part of the C11 standard. These functions include additional parameters that specify the maximum size of the destination buffer, which can help prevent buffer overflow vulnerabilities.\n\n## Source Code Fix Recommendation\n\nReplace the `memmove` function with `memmove_s` or `memcpy_s`. Here is an example of how to do it:\n\n```cpp\n#include <string.h>\n\nvoid unsafe(char *src, char *dest, size_t n) {\n    memmove(dest, src, n);\n}\n\nvoid safe(char *src, char *dest, size_t n, size_t max) {\n    memmove_s(dest, max, src, n);\n}\n```\n\nIn this example, `memmove_s` is used instead of `memmove`. The `max` parameter specifies the maximum size of the destination buffer.\n\n## Library Dependencies\n\nThe `string.h` library is required for the `memmove` and `memmove_s` functions.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "a50d490e-6503-3f0b-a13f-7ebe670ded38",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `malloc` function in C++ is used to dynamically allocate memory at runtime. The vulnerability arises when the size of the memory to be allocated is not properly validated or calculated, leading to buffer overflow, memory corruption, or other related issues. This can potentially allow an attacker to execute arbitrary code or cause a Denial of Service (DoS) attack.\n\n## Mitigation Advice\n\n1. Always validate the size of the memory to be allocated. Avoid allocating large blocks of memory that could potentially cause the program to run out of memory.\n\n2. Use functions that limit the amount of memory that can be written, such as `strncpy` instead of `strcpy`.\n\n3. Consider using modern C++ features like smart pointers (`std::unique_ptr`, `std::shared_ptr`) which automatically manage memory and help prevent memory leaks.\n\n4. Regularly use static code analysis tools to detect potential vulnerabilities in the code.\n\n## Source Code Fix Recommendation\n\nInstead of using `malloc`, consider using `new` in C++ which is type-safe and throws an exception if the allocation fails.\n\n```cpp\nT* ptr = new T;\n```\n\nRemember to deallocate the memory using `delete` when it is no longer needed.\n\n```cpp\ndelete ptr;\n```\n\n## Library Dependencies\n\nThe `malloc` function is part of the C Standard Library (`<cstdlib>` in C++) and does not require any additional libraries.\n\n## References\n\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-131: Incorrect Calculation of Buffer Size](https://cwe.mitre.org/data/definitions/131.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "bced224c-e16c-3566-a62c-d12c0c2a37ad",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `malloc` function in C++ is used to dynamically allocate memory at runtime. The vulnerability arises when the size of the memory to be allocated is not properly validated or calculated, leading to buffer overflow, memory corruption, or other related issues. This can potentially allow an attacker to execute arbitrary code or cause a Denial of Service (DoS) attack.\n\n## Mitigation Advice\n\n1. Always validate the size of the memory to be allocated. Avoid allocating large blocks of memory that could potentially cause the program to run out of memory.\n\n2. Use functions that limit the amount of memory that can be written, such as `strncpy` instead of `strcpy`.\n\n3. Consider using modern C++ features like smart pointers (`std::unique_ptr`, `std::shared_ptr`) which automatically manage memory and help prevent memory leaks.\n\n4. Regularly use static code analysis tools to detect potential vulnerabilities in the code.\n\n## Source Code Fix Recommendation\n\nInstead of using `malloc`, consider using `new` in C++ which is type-safe and throws an exception if the allocation fails.\n\n```cpp\nT* ptr = new T;\n```\n\nRemember to deallocate the memory using `delete` when it is no longer needed.\n\n```cpp\ndelete ptr;\n```\n\n## Library Dependencies\n\nThe `malloc` function is part of the C Standard Library (`<cstdlib>` in C++) and does not require any additional libraries.\n\n## References\n\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-131: Incorrect Calculation of Buffer Size](https://cwe.mitre.org/data/definitions/131.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "90f6ad28-0788-360c-b06e-3cef959ea4df",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `malloc` function in C++ is used to dynamically allocate memory at runtime. However, it can be a source of vulnerabilities if not used properly. The most common issues are:\n\n- Not checking if `malloc` returns `NULL`, which indicates that the memory allocation failed. This can lead to null pointer dereferencing, which is a serious vulnerability that can crash the program or lead to arbitrary code execution.\n- Not initializing the allocated memory, which can lead to information leakage.\n- Allocating too much memory, which can lead to integer overflow or underflow, and subsequently to buffer overflow vulnerabilities.\n\n## Mitigation Advice\n\n- Always check if `malloc` returns `NULL`. If it does, handle the error gracefully.\n- Initialize the allocated memory to a known value, preferably zero, using `memset` or `calloc`.\n- Be careful with the amount of memory you allocate. Make sure it's not too large to prevent integer overflow or underflow.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to use `malloc` safely:\n\n```cpp\n#include <cstdlib>\n#include <cstring>\n\nvoid* safe_malloc(std::size_t n) {\n    void* ptr = std::malloc(n);\n    if (ptr == NULL) {\n        // handle error\n        std::exit(EXIT_FAILURE);\n    }\n    std::memset(ptr, 0, n);\n    return ptr;\n}\n```\n\nIn this code, we first check if `malloc` returns `NULL`. If it does, we handle the error by exiting the program. Then, we initialize the allocated memory to zero using `memset`.\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `<cstdlib>` for `std::malloc` and `std::exit`\n- `<cstring>` for `std::memset`\n\n## References\n\n- [CWE-690: Unchecked Return Value to NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/690.html)\n- [CWE-908: Use of Uninitialized Resource](https://cwe.mitre.org/data/definitions/908.html)\n- [CWE-680: Integer Overflow to Buffer Overflow](https://cwe.mitre.org/data/definitions/680.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "144e20f6-b100-3de6-831c-eaf4e94246d5",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `malloc` function in C++ is used to dynamically allocate memory at runtime. However, it can be a source of vulnerabilities if not used properly. The most common issues are:\n\n- Not checking if `malloc` returns `NULL`, which indicates that the memory allocation failed. This can lead to null pointer dereferencing, which is a serious vulnerability that can crash the program or lead to arbitrary code execution.\n- Not initializing the allocated memory, which can lead to information leakage.\n- Allocating too much memory, which can lead to integer overflow or underflow, and subsequently to buffer overflow vulnerabilities.\n\n## Mitigation Advice\n\n- Always check if `malloc` returns `NULL`. If it does, handle the error gracefully.\n- Initialize the allocated memory to a known value, preferably zero, using `memset` or `calloc`.\n- Be careful with the amount of memory you allocate. Make sure it's not too large to prevent integer overflow or underflow.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to use `malloc` safely:\n\n```cpp\n#include <cstdlib>\n#include <cstring>\n\nvoid* safe_malloc(std::size_t n) {\n    void* ptr = std::malloc(n);\n    if (ptr == NULL) {\n        // handle error\n        std::exit(EXIT_FAILURE);\n    }\n    std::memset(ptr, 0, n);\n    return ptr;\n}\n```\n\nIn this code, we first check if `malloc` returns `NULL`. If it does, we handle the error by exiting the program. Then, we initialize the allocated memory to zero using `memset`.\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `<cstdlib>` for `std::malloc` and `std::exit`\n- `<cstring>` for `std::memset`\n\n## References\n\n- [CWE-690: Unchecked Return Value to NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/690.html)\n- [CWE-908: Use of Uninitialized Resource](https://cwe.mitre.org/data/definitions/908.html)\n- [CWE-680: Integer Overflow to Buffer Overflow](https://cwe.mitre.org/data/definitions/680.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "52af9551-ee35-3b30-a55b-5f00cef411e1",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `malloc` function in C++ is used to dynamically allocate memory at runtime. However, it can be a source of vulnerabilities if not used properly. The most common issues are:\n\n- Not checking if `malloc` returns `NULL`, which indicates that the memory allocation failed. This can lead to null pointer dereferencing, which is a serious vulnerability that can crash the program or lead to arbitrary code execution.\n- Not initializing the allocated memory, which can lead to information leakage.\n- Allocating too much memory, which can lead to integer overflow or underflow, and subsequently to buffer overflow vulnerabilities.\n\n## Mitigation Advice\n\n- Always check if `malloc` returns `NULL`. If it does, handle the error gracefully.\n- Initialize the allocated memory to a known value, preferably zero, using `memset` or `calloc`.\n- Be careful with the amount of memory you allocate. Make sure it's not too large to prevent integer overflow or underflow.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to use `malloc` safely:\n\n```cpp\n#include <cstdlib>\n#include <cstring>\n\nvoid* safe_malloc(std::size_t n) {\n    void* ptr = std::malloc(n);\n    if (ptr == NULL) {\n        // handle error\n        std::exit(EXIT_FAILURE);\n    }\n    std::memset(ptr, 0, n);\n    return ptr;\n}\n```\n\nIn this code, we first check if `malloc` returns `NULL`. If it does, we handle the error by exiting the program. Then, we initialize the allocated memory to zero using `memset`.\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `<cstdlib>` for `std::malloc` and `std::exit`\n- `<cstring>` for `std::memset`\n\n## References\n\n- [CWE-690: Unchecked Return Value to NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/690.html)\n- [CWE-908: Use of Uninitialized Resource](https://cwe.mitre.org/data/definitions/908.html)\n- [CWE-680: Integer Overflow to Buffer Overflow](https://cwe.mitre.org/data/definitions/680.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "c31d9184-a97d-3ca0-84af-a4c695e82bea",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards. One such function is `fprintf`.\n\nThe `fprintf` function can lead to vulnerabilities if not used correctly. It can cause format string vulnerabilities if the format string is not a constant, or if it's composed dynamically, it can lead to buffer overflows if the output is larger than the buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to `fprintf` such as `snprintf` or `vsnprintf`. These functions include the size of the buffer as an argument, which can prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nInstead of using `fprintf`, use `snprintf` or `vsnprintf`. Here is an example:\n\n```cpp\n#include <stdio.h>\n\nvoid safe_function(const char* format, ...) {\n    char buffer[1024];\n    va_list args;\n    va_start(args, format);\n    vsnprintf(buffer, sizeof(buffer), format, args);\n    va_end(args);\n    // Now buffer contains the formatted string.\n    // You can write it to file with fwrite or similar\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- stdio.h\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n\n## CWE\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            }
          ],
          "language": "en-US",
          "contents": [
            "localizedData",
            "nonLocalizedData"
          ],
          "isComprehensive": false
        }
      },
      "language": "en-US",
      "results": [
        {
          "ruleId": "028f8d1f-660f-3720-aad1-2f621a349a10",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "thrust/system/cuda/detail/bulk/detail/terminate.hpp"
                },
                "region": {
                  "startLine": 60,
                  "startColumn": 4,
                  "endLine": 60,
                  "endColumn": 10,
                  "charOffset": 1323,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "49243c74-9c7d-33d5-b218-45c70e89c8e3",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "thrust/system/cuda/detail/bulk/detail/terminate.hpp"
                },
                "region": {
                  "startLine": 62,
                  "startColumn": 4,
                  "endLine": 62,
                  "endColumn": 10,
                  "charOffset": 1417,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "ae47b75d-e0b8-3c64-a026-299e93f80329",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "thrust/system/cuda/detail/bulk/detail/terminate.hpp"
                },
                "region": {
                  "startLine": 47,
                  "startColumn": 7,
                  "endLine": 47,
                  "endColumn": 13,
                  "charOffset": 1104,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "26aaa792-ef8b-3990-a8d5-01d40f91f5ca",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unsecured URL Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "thrust/system/cuda/detail/bulk/detail/config.hpp"
                },
                "region": {
                  "startLine": 39,
                  "startColumn": 35,
                  "endLine": 39,
                  "endColumn": 59,
                  "charOffset": 1244,
                  "charLength": 24,
                  "snippet": {
                    "text": "http://thrust.github.io)",
                    "rendered": {
                      "text": "http://thrust.github.io)",
                      "markdown": "`http://thrust.github.io)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "An HTTP-based URL without TLS was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "thrust/system/cuda/detail/bulk/detail/config.hpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1244,
                        "charLength": 24
                      },
                      "insertedContent": {
                        "text": "https://thrust.github.io)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "ThreatModel.Integration.HTTP"
            ]
          }
        },
        {
          "ruleId": "1fb8ff2b-6bab-3f63-b10b-cc7d8cdaace7",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "thrust/system/cuda/detail/bulk/detail/throw_on_error.hpp"
                },
                "region": {
                  "startLine": 69,
                  "startColumn": 4,
                  "endLine": 69,
                  "endColumn": 10,
                  "charOffset": 1911,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "5d37606b-996f-3178-9684-12b060b1d66a",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "thrust/system/cuda/detail/bulk/detail/throw_on_error.hpp"
                },
                "region": {
                  "startLine": 67,
                  "startColumn": 4,
                  "endLine": 67,
                  "endColumn": 10,
                  "charOffset": 1815,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "ebfb17ce-f98e-3ece-865a-080698d3312e",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "thrust/system/cuda/detail/bulk/detail/throw_on_error.hpp"
                },
                "region": {
                  "startLine": 49,
                  "startColumn": 4,
                  "endLine": 49,
                  "endColumn": 10,
                  "charOffset": 1383,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "ff19dbe8-92d8-3ca4-830d-38363e12d0f2",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "thrust/system/cuda/detail/bulk/detail/throw_on_error.hpp"
                },
                "region": {
                  "startLine": 47,
                  "startColumn": 4,
                  "endLine": 47,
                  "endColumn": 10,
                  "charOffset": 1288,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "eb4f5517-af60-3eef-961e-d39fcb78859a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "thrust/system/tbb/detail/memory.inl"
                },
                "region": {
                  "startLine": 80,
                  "startColumn": 21,
                  "endLine": 80,
                  "endColumn": 42,
                  "charOffset": 2113,
                  "charLength": 21,
                  "snippet": {
                    "text": "malloc(std::size_t n)",
                    "rendered": {
                      "text": "malloc(std::size_t n)",
                      "markdown": "`malloc(std::size_t n)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "thrust/system/tbb/detail/memory.inl"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2113,
                        "charLength": 21
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "02e60970-02c5-306f-a865-3107d5a9d415",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "thrust/system/tbb/detail/memory.inl"
                },
                "region": {
                  "startLine": 91,
                  "startColumn": 11,
                  "endLine": 91,
                  "endColumn": 32,
                  "charOffset": 2416,
                  "charLength": 21,
                  "snippet": {
                    "text": "malloc(std::size_t n)",
                    "rendered": {
                      "text": "malloc(std::size_t n)",
                      "markdown": "`malloc(std::size_t n)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "thrust/system/tbb/detail/memory.inl"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2416,
                        "charLength": 21
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "170923f4-5c91-3798-a1c0-53b222a7db73",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "thrust/system/tbb/detail/memory.inl"
                },
                "region": {
                  "startLine": 93,
                  "startColumn": 47,
                  "endLine": 93,
                  "endColumn": 63,
                  "charOffset": 2487,
                  "charLength": 16,
                  "snippet": {
                    "text": "malloc(sizeof(T)",
                    "rendered": {
                      "text": "malloc(sizeof(T)",
                      "markdown": "`malloc(sizeof(T)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "thrust/system/tbb/detail/memory.inl"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2487,
                        "charLength": 16
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "ae035c1c-2366-308c-be7a-646d246e134c",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "thrust/system/cuda/detail/bulk/future.hpp"
                },
                "region": {
                  "startLine": 72,
                  "startColumn": 12,
                  "endLine": 72,
                  "endColumn": 18,
                  "charOffset": 1716,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "17cd622b-0488-300c-b25c-90cc5bff81ad",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "thrust/system/cuda/detail/bulk/malloc.hpp"
                },
                "region": {
                  "startLine": 549,
                  "startColumn": 18,
                  "endLine": 549,
                  "endColumn": 35,
                  "charOffset": 13430,
                  "charLength": 17,
                  "snippet": {
                    "text": "malloc(num_bytes)",
                    "rendered": {
                      "text": "malloc(num_bytes)",
                      "markdown": "`malloc(num_bytes)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "thrust/system/cuda/detail/bulk/malloc.hpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13430,
                        "charLength": 17
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "c2636310-528f-3f0b-9397-2815490b2cdf",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "thrust/system/cuda/detail/bulk/future.hpp"
                },
                "region": {
                  "startLine": 61,
                  "startColumn": 10,
                  "endLine": 61,
                  "endColumn": 16,
                  "charOffset": 1437,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "23c520eb-78c3-385c-a577-b16d93996cb4",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "thrust/system/cuda/detail/bulk/malloc.hpp"
                },
                "region": {
                  "startLine": 533,
                  "startColumn": 18,
                  "endLine": 533,
                  "endColumn": 35,
                  "charOffset": 13120,
                  "charLength": 17,
                  "snippet": {
                    "text": "malloc(num_bytes)",
                    "rendered": {
                      "text": "malloc(num_bytes)",
                      "markdown": "`malloc(num_bytes)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "thrust/system/cuda/detail/bulk/malloc.hpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13120,
                        "charLength": 17
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "f9beb10d-7c26-371f-aede-940c1f72163e",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Found\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "thrust/system/detail/sequential/trivial_copy.h"
                },
                "region": {
                  "startLine": 48,
                  "startColumn": 7,
                  "endLine": 48,
                  "endColumn": 14,
                  "charOffset": 1130,
                  "charLength": 7,
                  "snippet": {
                    "text": "memmove",
                    "rendered": {
                      "text": "memmove",
                      "markdown": "`memmove`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "a50d490e-6503-3f0b-a13f-7ebe670ded38",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "thrust/system/cuda/detail/memory.inl"
                },
                "region": {
                  "startLine": 77,
                  "startColumn": 48,
                  "endLine": 77,
                  "endColumn": 64,
                  "charOffset": 2181,
                  "charLength": 16,
                  "snippet": {
                    "text": "malloc(sizeof(T)",
                    "rendered": {
                      "text": "malloc(sizeof(T)",
                      "markdown": "`malloc(sizeof(T)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "thrust/system/cuda/detail/memory.inl"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2181,
                        "charLength": 16
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "bced224c-e16c-3566-a62c-d12c0c2a37ad",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "thrust/system/omp/detail/memory.inl"
                },
                "region": {
                  "startLine": 93,
                  "startColumn": 47,
                  "endLine": 93,
                  "endColumn": 63,
                  "charOffset": 2487,
                  "charLength": 16,
                  "snippet": {
                    "text": "malloc(sizeof(T)",
                    "rendered": {
                      "text": "malloc(sizeof(T)",
                      "markdown": "`malloc(sizeof(T)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "thrust/system/omp/detail/memory.inl"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2487,
                        "charLength": 16
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "90f6ad28-0788-360c-b06e-3cef959ea4df",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "thrust/system/omp/detail/memory.inl"
                },
                "region": {
                  "startLine": 91,
                  "startColumn": 11,
                  "endLine": 91,
                  "endColumn": 32,
                  "charOffset": 2416,
                  "charLength": 21,
                  "snippet": {
                    "text": "malloc(std::size_t n)",
                    "rendered": {
                      "text": "malloc(std::size_t n)",
                      "markdown": "`malloc(std::size_t n)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "thrust/system/omp/detail/memory.inl"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2416,
                        "charLength": 21
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "144e20f6-b100-3de6-831c-eaf4e94246d5",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "thrust/system/omp/detail/memory.inl"
                },
                "region": {
                  "startLine": 80,
                  "startColumn": 21,
                  "endLine": 80,
                  "endColumn": 42,
                  "charOffset": 2113,
                  "charLength": 21,
                  "snippet": {
                    "text": "malloc(std::size_t n)",
                    "rendered": {
                      "text": "malloc(std::size_t n)",
                      "markdown": "`malloc(std::size_t n)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "thrust/system/omp/detail/memory.inl"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2113,
                        "charLength": 21
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "52af9551-ee35-3b30-a55b-5f00cef411e1",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "thrust/system/cuda/detail/memory.inl"
                },
                "region": {
                  "startLine": 75,
                  "startColumn": 11,
                  "endLine": 75,
                  "endColumn": 32,
                  "charOffset": 2109,
                  "charLength": 21,
                  "snippet": {
                    "text": "malloc(std::size_t n)",
                    "rendered": {
                      "text": "malloc(std::size_t n)",
                      "markdown": "`malloc(std::size_t n)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "thrust/system/cuda/detail/memory.inl"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2109,
                        "charLength": 21
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "c31d9184-a97d-3ca0-84af-a4c695e82bea",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "thrust/system/cuda/detail/trivial_copy.inl"
                },
                "region": {
                  "startLine": 106,
                  "startColumn": 6,
                  "endLine": 106,
                  "endColumn": 13,
                  "charOffset": 3528,
                  "charLength": 7,
                  "snippet": {
                    "text": "fprintf",
                    "rendered": {
                      "text": "fprintf",
                      "markdown": "`fprintf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        }
      ],
      "newlineSequences": [
        "\r\n",
        "\n"
      ]
    }
  ]
}